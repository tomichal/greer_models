---
title: "Model Fitting Combo_nieve_cohort"
author: "Greer Waldrop"
date: "2/13/2025"
output: html_document
---

#you will need to input your paths in the first chunk and in all the chunks for the models you need to input your data in the model matrix and then the last chuck you need to put the output path for the csv of the model fitting results; you will also need the tsv file of "biomart_protein_coding_genes_withgeneinfo.tsv" loaded into your working directory#

```{r Functions}
load_data <- function(metadata_filepath, counts_filepath, pc_genes_filepath) {
  ms_counts <- read_csv(counts_filepath)
  counts <- ms_counts %>%
    as.data.frame() %>%
    column_to_rownames(var = "...1")

  meta_MS <- read_csv(metadata_filepath)

  columns_to_keep <- meta_MS$study_id

  subset_data_ms_drop <- counts[, colnames(counts) %in% columns_to_keep]

  matrix_ms_predrop <- as.matrix(subset_data_ms_drop)

  pc_genes <- read_csv(pc_genes_filepath)

  list(
    # counts = counts,
    meta_MS = meta_MS,
    matrix_ms_predrop = matrix_ms_predrop,
    pc_genes = pc_genes
  )
}

prepare_data <- function(matrix_ms_predrop, meta_MS) {
  #dropping zero genes
  row_sums_combo <- rowSums(matrix_ms_predrop)
  zero_row_names_combo <- rownames(matrix_ms_predrop)[row_sums_combo == 0]
  print(matrix_ms_predrop)
  matrix_combo_ms_ns_drop <- matrix_ms_predrop[rowSums(matrix_ms_predrop) != 0,]

  #checking if there are zero sum rows
  row_sums_combo_drop <- rowSums(matrix_ms_predrop)
  zero_row_names_combo_after_drop <- rownames(matrix_ms_predrop)[rowSums(matrix_ms_predrop) == 0]
  print(zero_row_names_combo_after_drop)


  print(addmargins(table(meta_MS$pleocytosis)))
  meta_MS$pleocytosis[is.na(meta_MS$pleocytosis)] <- 3

  print(addmargins(table(meta_MS$enhancing)))
  meta_MS$enhancing[is.na(meta_MS$enhancing)] <- "Missing"

  print(addmargins(table(meta_MS$immunetherapyattimeoflp)))
  meta_MS$immunetherapyattimeoflp[is.na(meta_MS$immunetherapyattimeoflp)] <- 2

  # Return the processed data
  list(
    matrix_combo_ms_ns_drop = matrix_combo_ms_ns_drop,
    meta_MS = meta_MS
  )
}

run_model <- function(Y, xFormula, maxIterOptimize = 400, V = NULL) {

  run_zinbFit <- function(zeroInflation) {
    zinbFit(
      Y,
      K = 2,
      X = if (is.null(V)) {
        model.matrix(
          xFormula,
          data = colData(se_combo_drop_nieve)
        )
      } else {
        model.matrix(
          xFormula,
          data = colData(se_combo_drop_nieve),
          V = V
        )
      },
      BPPARAM = BiocParallel::SerialParam(),
      maxiter.optimize = maxIterOptimize,
      verbose = FALSE,
      zeroinflation = zeroInflation
    )
  }

  #ZINB
  zinb_nieve_cohort <- run_zinbFit(zeroInflation = TRUE)
  ZI_ll <- loglik(zinb_nieve_cohort, zinbSim(zinb_nieve_cohort)$counts)
  ZI_aic <- zinbAIC(zinb_nieve_cohort, t(assay(se_combo_drop_nieve)))
  ZI_df <- nParams(zinb_nieve_cohort)

  #neg binomial crude mdoel
  nb_nieve_cohort <- run_zinbFit(zeroInflation = FALSE)
  NB_ll <- loglik(nb_nieve_cohort, zinbSim(nb_nieve_cohort)$counts)
  NB_aic <- zinbAIC(nb_nieve_cohort, t(assay(se_combo_drop_nieve)))
  NB_df <- nParams(nb_nieve_cohort)

  list(
    ZI_ll = ZI_ll,
    ZI_aic = ZI_aic,
    ZI_df = ZI_df,
    NB_ll = NB_ll,
    NB_aic = NB_aic,
    NB_df = NB_df
  )
}

summarized_experiment <- function(matrix_combo_ms_ns_drop, meta_MS) {

  categorize_quartiles <- function(value, quartiles) {
    if (value <= quartiles[2]) {
      return("Q1")
    } else if (value <= quartiles[3]) {
      return("Q2")
    } else if (value <= quartiles[4]) {
      return("Q3")
    } else {
      return("Q4")
    }
  }

  se_combo_drop_nieve <- SummarizedExperiment(
    assays = list(counts = matrix_combo_ms_ns_drop), colData = data.frame(meta_MS)
  )

  #Add that quartile variable to the Summarized Experiment object
  se_combo_drop_nieve$Quartiletotal <- sapply(
    se_combo_drop_nieve$totaltranscripts,
    categorize_quartiles,

    #Make Quartiles of Number of Non Zero Genes and Total Transcripts and time from collection to sequencing just for ease of model convering
    quartiles = quantile(se_combo_drop_nieve$totaltranscripts, probs = c(0, 0.25, 0.5, 0.75, 1))
  )

  #Add that quartile variable to the Summarized Experiment object
  se_combo_drop_nieve$Quartilenonzero <- sapply(
    se_combo_drop_nieve$numnonzero,
    categorize_quartiles,

    #numnonzero quartiles
    quartiles = quantile(se_combo_drop_nieve$numnonzero, probs = c(0, 0.25, 0.5, 0.75, 1))
  )

  #Add that quartile variable to the Summarized Experiment object
  se_combo_drop_nieve$Quartilefreezer <- sapply(
    se_combo_drop_nieve$coll_to_seq,
    categorize_quartiles,

    #freezer time quartiles
    quartiles = quantile(se_combo_drop_nieve$coll_to_seq, probs = c(0, 0.25, 0.5, 0.75, 1))
  )

  return(se_combo_drop_nieve)
}

```


```{r Initialize}
library(BiocParallel)
library(rmarkdown)
library(knitr)
library(zinbwave)
library(readr)
library(tidyr)
library(tibble)
library(biomaRt)
library(dplyr)

knitr::opts_chunk$set(echo = TRUE)

setwd("~/dev/r/greer_models")

loaded_data <- load_data(
  "./input/meta_data_lazar.csv",
  "./input/gene_count_lazar_1000.csv",
  "./input/pc_genes.csv"
)
meta_MS <- loaded_data$meta_MS
matrix_ms_predrop <- loaded_data$matrix_ms_predrop
pc_genes <- loaded_data$pc_genes

prepared_data <- prepare_data(matrix_ms_predrop, meta_MS)

meta_MS <- prepared_data$meta_MS
matrix_combo_ms_ns_drop <- prepared_data$matrix_combo_ms_ns_drop

se_combo_drop_nieve <- summarized_experiment(matrix_combo_ms_ns_drop, meta_MS)
```


```{r Model Definitions}
meta_ms_cols <- c(
  "age_at_csf",
  "sex",
  "race",
  "ethnicity",
  "enhancing",
  "csf_wbc",
  "immunetherapyattimeoflp",
  "coll_to_seq",
  "percentzero",
  "totaltranscripts",
  "numnonzero",
  "pleocytosis"
)

combinations <- list()
model_definitions <- list()
sequence <- 1:length(meta_ms_cols)
for (i in sequence) {
  combination_matrix <- combn(meta_ms_cols, i, simplify = TRUE)
  new_combinations <- split(combination_matrix, col(combination_matrix))
  combinations <- c(combinations, new_combinations)
}
for (attrs in combinations) {
  formula_x <- reformulate(termlabels = paste0("se_combo_drop_nieve$", attrs))
  model_definitions <- c(
    model_definitions,
    list(
      list(
        attrs = attrs,
        name = paste(attrs, collapse = "_"),
        title = paste(attrs, collapse = " + "),
        formula_x = formula_x
      )
    )
  )
}
```

```{r Running Models and Making Table for AIC and ll}
row_names <- c("ZI AIC", "ZI -ll", "ZI-df", "NB AIC", "NB -ll", "NB df")
num_rows <- length(row_names)
fit_df <- data.frame(matrix(ncol = 0, nrow = num_rows))
rownames(fit_df) <- row_names

for (i in list(1, 2)) {
  # for (i in seq_along(model_definitions)) {
  for (formula_v in list(NULL, (~pc_genes$gcc + pc_genes$length))) {
    title <- if (!is.null(formula_v)) paste(model_definitions[[i]]$title, "gcc + length", sep = " + ") else model_definitions[[i]]$title
    formula_x <- model_definitions[[i]]$formula_x

    result <- run_model(
      Y = se_combo_drop_nieve,
      xFormula = formula_x,
      maxIterOptimize = 400,
      V = formula_v
    )
    fit_df[[title]] <- c(
      result$ZI_aic,
      result$ZI_ll,
      result$ZI_df,
      result$NB_aic,
      result$NB_ll,
      result$NB_df
    )
  }
}

row1 <- fit_df["ZI -ll",]
row2 <- fit_df["NB -ll",]
row1 <- as.numeric(row1)
row2 <- as.numeric(row2)

# Perform subtraction, this will give you the difference in the -2 logliklihood wihch is the statistic which you could in theory run a LR test on but these models aren't nested so cant technically do it 
result_row <- 2 * (row1 - row2)

result_df_combo_drop_nieve_cohort <- as.data.frame(t(result_row))
colnames(result_df_combo_drop_nieve_cohort) <- colnames(fit_df)  # Match column names
rownames(result_df_combo_drop_nieve_cohort)[1] <- "Difference in LL"

# Bind the new row (differce in the negative 2 ll) to the original DataFrame
combo_ModelCompare_drop_nieve_cohort <- rbind(fit_df, result_df_combo_drop_nieve_cohort)

# Create './output' folder if it does not exist
if (!dir.exists("./output")) {
  dir.create("./output", showWarnings = FALSE)
}

combo_ModelCompare_drop_nieve_cohort <- combo_ModelCompare_drop_nieve_cohort[,
  order(as.numeric(combo_ModelCompare_drop_nieve_cohort["ZI AIC",]))
]

write.csv(combo_ModelCompare_drop_nieve_cohort, file = "./output/model_fiting_table_combo_drop_nieve_cohort_NEW.csv", row.names = TRUE)

```



