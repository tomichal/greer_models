---
title: "Model Fitting by Michal"
author: "Greer Waldrop"
date: "2/13/2025"
output: html_document
---

#you will need to input your paths (1: all meta data in one file with the study id column label "study_id" 2: all raw count data in one file  3) Gene Info from Biomart (i have a csv made from "biomart_protein_coding_genes_withgeneinfo.tsv" that you can use if you dont have it already) in the first chunk#

#Ensuring only data that has meta-data is included in the count data and adding missing values to data you want included in the models that have missing values
```{r ensuring that only data in meta-data is included in count data -- ONLY USE IF YOU NEED THIS STEP }

#load in your data, first file path is meta, second is count, third is protein coding gene info
load_data <- function(metadata_filepath, counts_filepath, pc_genes_filepath) {
  counts <- read_csv(counts_filepath) #this makes a count dataframe
  counts <- counts %>%
    as.data.frame() %>%
    column_to_rownames(var = "...1") #this makes a new count dataframe with gene names as row names

  meta_data <- read_csv(metadata_filepath) #this makes a metadata dataframe

  columns_to_keep <- meta_data$study_id #this give you the sampleids in your meta data as a vector 

  subset_data_drop <- counts[, colnames(counts) %in% columns_to_keep] #this subsets the count data so that only sampleids in the meta data are kept in the count data 

  matrix_predrop <- as.matrix(subset_data_drop) #this makes count dataframe (with only meta-data sampleid) a count matric

  pc_genes <- read_csv(pc_genes_filepath) #this makes a dataframe of all the gene level info for only protein coding genes taken from biomart in Fall 2024

  list(
    # counts = counts,
    meta_data = meta_data,
    matrix_predrop = matrix_predrop,
    pc_genes = pc_genes
  )   #this is just lists what me made so we can access these things later when we run the function
}

prepare_data <- function(matrix_predrop, meta_data) {
  #dropping all zero genes 
  row_sums_pre <- rowSums(matrix_predrop) #makes a vectors of the rowSums (total gene counts)
  zero_row_names_combo <- rownames(matrix_predrop)[row_sums_pre == 0] #makes a vector of the gene names that have total zero counts
  matrix_after_drop <- matrix_predrop[rowSums(matrix_predrop) != 0,] #makes a count matrix after dropping all zero gene counts

  #checking if there are zero sum rows
  zero_row_names_after_drop <- rownames(matrix_after_drop)[rowSums(matrix_after_drop) == 0]
  print(zero_row_names_after_drop)


  #below will add a "missing value" to any variable you want to include in the models that has missing data
  #print(addmargins(table(meta_data$pleocytosis)))
  #meta_MS$pleocytosis[is.na(meta_data$pleocytosis)] <- 3

  #print(addmargins(table(meta_data$enhancing)))
  #meta_MS$enhancing[is.na(meta_data$enhancing)] <- "Missing"

  #print(addmargins(table(meta_data$immunetherapyattimeoflp)))
  #meta_MS$immunetherapyattimeoflp[is.na(meta_data$immunetherapyattimeoflp)] <- 2

  #Return the processed data
  list(
    matrix_after_drop = matrix_after_drop,
    meta_data = meta_data
  )
}

```

#Making a Summarized Experiment Object and adding quantile of continuous data to summarized experiment
```{r making a summarized experiment object}
summarized_experiment_with_quartiles <- function(matrix_after_drop, meta_data) {

  categorize_quartiles <- function(value, quartiles) {
    if (value <= quartiles[2]) {
      return("Q1")
    } else if (value <= quartiles[3]) {
      return("Q2")
    } else if (value <= quartiles[4]) {
      return("Q3")
    } else {
      return("Q4")
    }
  }

  se <- SummarizedExperiment(
    assays = list(counts = matrix_after_drop), colData = data.frame(meta_data)
  )

  for (col in  c(
    "totaltranscripts",
    "numnonzero",
    "coll_to_seq",
    "age_at_csf",
    "percentzero"
  )) {
    quartile_name <- paste0("quartile_", col)
    se[[quartile_name]] <- sapply(
      se[[col]],
      categorize_quartiles,

      quartiles = quantile(se[[col]], probs = c(0, 0.25, 0.5, 0.75, 1))
    )
  }

  return(se)
}
```

```{r Functions DO NOT TOUCH}
run_model <- function(Y, xFormula, maxIterOptimize = 400, V = NULL) {

  run_zinbFit <- function(zeroInflation) {
    zinbFit(
      Y,
      K = 2,
      X = if (is.null(V)) {
        model.matrix(
          xFormula,
          data = colData(se)
        )
      } else {
        model.matrix(
          xFormula,
          data = colData(se),
          V = V
        )
      },
      BPPARAM = BiocParallel::SerialParam(),
      maxiter.optimize = maxIterOptimize,
      verbose = FALSE,
      zeroinflation = zeroInflation
    )
  }

  #ZINB
  zinb_model <- run_zinbFit(zeroInflation = TRUE)
  ZI_ll <- loglik(zinb_model, zinbSim(zinb_model)$counts)
  ZI_aic <- zinbAIC(zinb_model, t(assay(se)))
  ZI_df <- nParams(zinb_model)

  #neg binomial crude mdoel
  nb_model <- run_zinbFit(zeroInflation = FALSE)
  NB_ll <- loglik(nb_model, zinbSim(nb_model)$counts)
  NB_aic <- zinbAIC(nb_model, t(assay(se)))
  NB_df <- nParams(nb_model)

  list(
    ZI_ll = ZI_ll,
    ZI_aic = ZI_aic,
    ZI_df = ZI_df,
    NB_ll = NB_ll,
    NB_aic = NB_aic,
    NB_df = NB_df
  )
}
```


```{r Initialize}
library(BiocParallel)
library(rmarkdown)
library(knitr)
library(zinbwave)
library(readr)
library(tidyr)
library(tibble)
library(biomaRt)
library(dplyr)

knitr::opts_chunk$set(echo = TRUE)

#set working directory to be the folder where your data is and where you want the output to go 
setwd("~/dev/r/greer_models")

output_folder_name <- './output'
output_file_path <- paste0(output_folder_name, "/model_comparisons.csv")

loaded_data <- load_data(
  "./input/meta_data_lazar.csv",  #meta data
  "./input/gene_count_lazar_1000.csv", #count matrix
  "./input/pc_genes.csv"  #pc gene info 
)
meta_data <- loaded_data$meta_data
matrix_predrop <- loaded_data$matrix_predrop
pc_genes <- loaded_data$pc_genes

prepared_data <- prepare_data(matrix_predrop, meta_data)

se <- summarized_experiment_with_quartiles(prepared_data$matrix_after_drop, prepared_data$meta_data)
```


```{r Model Definitions}
meta_data_cols <- c(
  # "sex",
  # "race",
  # "ethnicity",
  # "enhancing",
  # "csf_wbc",
  # "immunetherapyattimeoflp",
  # "pleocytosis",
  "quartile_age_at_csf",
  "quartile_coll_to_seq",
  "quartile_percentzero",
  "quartile_totaltranscripts",
  "quartile_numnonzero"
)

combinations <- list()
model_definitions <- list()
sequence <- 1:length(meta_data_cols)
for (i in sequence) {
  combination_matrix <- combn(meta_data_cols, i, simplify = TRUE)
  new_combinations <- split(combination_matrix, col(combination_matrix))
  combinations <- c(combinations, new_combinations)
}
for (attrs in combinations) {
  formula_x <- reformulate(termlabels = paste0("se$", attrs))
  model_definitions <- c(
    model_definitions,
    list(
      list(
        attrs = attrs,
        name = paste(attrs, collapse = "_"),
        title = paste(attrs, collapse = " + "),
        formula_x = formula_x
      )
    )
  )
}
```

```{r Running Models and Making Table for AIC and ll}
row_names <- c("ZI AIC", "ZI -ll", "ZI-df", "NB AIC", "NB -ll", "NB df")
num_rows <- length(row_names)
fit_df <- data.frame(matrix(ncol = 0, nrow = num_rows))
rownames(fit_df) <- row_names

for (i in list(1)) {
  # for (i in seq_along(model_definitions)) {
  for (formula_v in list(NULL, (~pc_genes$gcc + pc_genes$length))) {
    title <- if (!is.null(formula_v)) paste(model_definitions[[i]]$title, "gcc + length", sep = " + ") else model_definitions[[i]]$title
    formula_x <- model_definitions[[i]]$formula_x

    result <- run_model(
      Y = se,
      xFormula = formula_x,
      maxIterOptimize = 400,
      V = formula_v
    )
    fit_df[[title]] <- c(
      result$ZI_aic,
      result$ZI_ll,
      result$ZI_df,
      result$NB_aic,
      result$NB_ll,
      result$NB_df
    )
  }
}

row1 <- fit_df["ZI -ll",]
row2 <- fit_df["NB -ll",]
row1 <- as.numeric(row1)
row2 <- as.numeric(row2)

# Perform subtraction, this will give you the difference in the -2 logliklihood wihch is the statistic which you could in theory run a LR test on but these models aren't nested so cant technically do it 
result_row <- 2 * (row1 - row2)

result_df_combo_drop_nieve_cohort <- as.data.frame(t(result_row))
colnames(result_df_combo_drop_nieve_cohort) <- colnames(fit_df)  # Match column names
rownames(result_df_combo_drop_nieve_cohort)[1] <- "Difference in LL"

# Bind the new row (differce in the negative 2 ll) to the original DataFrame
combo_ModelCompare_drop_nieve_cohort <- rbind(fit_df, result_df_combo_drop_nieve_cohort)

# Create './output' folder if it does not exist
if (!dir.exists(output_folder_name)) {
  dir.create(output_folder_name, showWarnings = FALSE)
}

combo_ModelCompare_drop_nieve_cohort <- combo_ModelCompare_drop_nieve_cohort[,
  order(as.numeric(combo_ModelCompare_drop_nieve_cohort["ZI AIC",]))
]

write.csv(combo_ModelCompare_drop_nieve_cohort, file = "./output/model_fiting_table_combo_drop_nieve_cohort_NEW.csv", row.names = TRUE)

```



